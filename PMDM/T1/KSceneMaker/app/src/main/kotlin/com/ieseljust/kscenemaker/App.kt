/*
 * This Kotlin source file was generated by the Gradle 'init' task.
 */

package com.ieseljust.kscenemaker

// Imports per gestionar el color de les imatges
import java.awt.Color
import kotlin.system.exitProcess

class App {
  
  private var escena = Escena()
  
  private fun getColor(color: String): Color {
    /*
     * Mètode auxiliar per tal de "traduir" els colors en mode text a la seua
     * representació com a constants en awt.Color
     */
    
    return when (color) {
      "roig" -> Color.RED
      "verd" -> Color.GREEN
      "blau" -> Color.BLUE
      "groc" -> Color.YELLOW
      "magenta" -> Color.MAGENTA
      "cyan" -> Color.CYAN
      "blanc" -> Color.WHITE
      "negre" -> Color.BLACK
      "gris" -> Color.GRAY
      "grisClar" -> Color.LIGHT_GRAY
      "grisFosc" -> Color.DARK_GRAY
      "rosa" -> Color.PINK
      "taronja" -> Color.ORANGE
      else -> Color.BLACK
    }
  }
  
  
  private fun addFigura(figura: List<String>) {
    when (figura[0]) {
      "rectangle" -> {
        try {
          val x = figura[1].toInt()
          val y = figura[2].toInt()
          val w = figura[3].toInt()
          val h = figura[4].toInt()
          val color = figura[5]
          
          // Si tot és correcte creem la figura rectangle
          val nouRect = Rectangle(x, y, w, h, this.getColor(color))
          // I l'afegim a la llista
          escena.add(nouRect)
        } catch (err: Exception) {
          println("\u001B[31m Arguments incorrectes \u001B[0m")
        }
      }
      
      "quadrat" -> {
        try {
          val x = figura[1].toInt()
          val y = figura[2].toInt()
          val c = figura[3].toInt()
          val color = figura[4]
          
          // Si tot és correcte creem la figura rectangle
          val nouQuadrat = Quadrat(x, y, c, this.getColor(color))
          // I l'afegim a la llista
          escena.add(nouQuadrat)
        } catch (err: Exception) {
          println("\u001B[31m Arguments incorrectes \u001B[0m")
        }
      }
      
      "ellipse" -> {
        try {
          val x = figura[1].toInt()
          val y = figura[2].toInt()
          val rX = figura[3].toInt()
          val rY = figura[4].toInt()
          val color = figura[5]
          
          // Si tot és correcte creem la figura rectangle
          val novaEllipse = Ellipse(x, y, rX, rY, this.getColor(color))
          // I l'afegim a la llista
          escena.add(novaEllipse)
        } catch (err: Exception) {
          println("\u001B[31m Arguments incorrectes \u001B[0m")
        }
      }
      
      "cercle" -> {
        try {
          val x = figura[1].toInt()
          val y = figura[2].toInt()
          val r = figura[3].toInt()
          val color = figura[4]
          
          // Si tot és correcte creem la figura rectangle
          val nouCercle = Cercle(x, y, r, this.getColor(color))
          // I l'afegim a la llista
          escena.add(nouCercle)
        } catch (err: Exception) {
          println("\u001B[31m Arguments incorrectes \u001B[0m")
        }
      }
      
      "linia" -> {
        try {
          val x = figura[1].toInt()
          val y = figura[2].toInt()
          val x2 = figura[3].toInt()
          val y2 = figura[4].toInt()
          val color = figura[5]
          
          // Si tot és correcte creem la figura rectangle
          val novaLinia = Linia(x, y, x2, y2, this.getColor(color))
          // I l'afegim a la llista
          escena.add(novaLinia)
        } catch (err: Exception) {
          println("\u001B[31m Arguments incorrectes \u001B[0m")
        }
      }
      
      else -> {
        println("\u001B[31m Figura no implementada \u001B[0m")
      }
      
    } // when
  }
  
  fun startCli() {
    do {
      // Preguntem la següent figura a emmagatzemar
      print("# Figura: ")
      
      val ordre: String = readLine()!!
      
      // Separem l'ordre introduida pel teclat en la forma:
      // "Figura Posicio Mida  Color"
      val components = ordre.split(" ")
      
      when (components[0]) {
        in arrayOf("rectangle", "cercle", "linia", "quadrat", "ellipse") -> {
          addFigura(components)
        }
        
        "dimensions" -> {
          // TODO: Agafar les dimensions de l'ordre
          // i modificar les propietats de l'escena
          try {
            escena.tamX = components[1].toInt()
            escena.tamY = components[2].toInt()
          } catch (e: java.lang.Exception) {
            // Si s'ha produït algun error als paràmetres, s'indica un error de sintaxi
            println(
              "\u001B[31m Error de sintaxi. La sintaxi correcta és:\n dimensions x y\u001B[0m"
            )
          }
          break
        }
        
        "list" -> escena.renderText()
        
        "render" -> escena.renderScene()
        
        "remotelist" -> {
          try {
            // Descarrega l'index de figures del servidor remot
            val liniaFitxers: ArrayList<String>? = RemoteManager.download("index.php") // Pot ser null
            // Ús del safe Call Operator
            var fitxers: List<String>? = liniaFitxers?.get(0)?.split("<br/>")
            
            for (fitxer in fitxers.orEmpty()) println(fitxer)
          } catch (e: Exception) {
            println("Excepció en la càrrega del fitxer: ")
            println(e)
          }
        }
        
        "get" -> {
          try {
            val fitxer: String = components[1]
            // Descarrega l'index de figures del servidor remot
            val novesFigures: ArrayList<String>? = RemoteManager.download(fitxer) // Pot ser null
            
            // Creem una nova escena
            escena = Escena()
            
            // La recorrem
            for (linia in novesFigures?.get(0)?.split("\n").orEmpty()) {
              val items: List<String>? = linia.split(" ")
              
              when (items!![0]) {
                in arrayOf("rectangle", "cercle", "linia", "quadrat", "ellipse") -> {
                  addFigura(items)
                }
                
                "dimensions" -> {
                  // Agafar les dimensions de l'ordre
                  // i modificar les propietats de l'escena
                  try {
                    escena.tamX = components[1].toInt()
                    escena.tamY = components[2].toInt()
                  } catch (e: java.lang.Exception) {
                    // Si s'ha produït algun error als paràmetres, s'indica un error de sintaxi
                    println(
                      "\u001B[31m Error de sintaxi. La sintaxi correcta és:\n dimensions x y\u001B[0m"
                    )
                  }
                  break
                }
              }// When
            }
          } catch (e: Exception) {
            println("Excepció en la càrrega del fitxer: ")
            println(e)
          }
        }
        
        "quit" -> {
          exitProcess(0)
        }
        
        else -> {
          println("\u001B[31m Figura no reconeguda \u001B[0m")
        }
      }
      
    } while (true)
  }
}

fun main(args: Array<String>) {
  val myApp = App()
  myApp.startCli()
}